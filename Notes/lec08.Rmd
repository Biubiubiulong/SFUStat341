---
title: "Lecture 8"
author: "Brad McNeney"
date: '2017-03-07'
output: beamer_presentation
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Grouping

## Subgroup summaries

\small

- Data visualization and modelling is often
in terms of subgroups.
- Illustrate with some data on enrollments
in Stat and Act Sci courses over the 2007/08 to
2015/16 academic years.
    - Data on full-time equivalents
    (FTEs, equal to 30 credit hours taught)
    by year and course.
- Recurring theme: Need to split the data into subgroups, 
transform or summarize, and reassemble, or unsplit.
    - Has come to be known as "split-apply-combine"

## Science enrollments database

\small

- Load the `scilong` data frame created by
`FTE.Rmd` 
    - Look through the `FTE.Rmd` script if you 
    haven't already.
    
\scriptsize

```{r,warning=FALSE,message=FALSE}
library(tidyverse)
load("scilong.RData")
head(scilong)
```

## Stat and Act Sci data 

\scriptsize

```{r}
stat <- filter(scilong,Subject=="STAT" | Subject=="ACMA")
head(stat)
```

## Split-apply-combine example 1: yearly percent FTEs

\small

- Suppose we want the percent of FTEs in a year
that are attributable to each course taught.
- Split the data by year, 
compute proportion of FTEs for each course in that year,
and combine the proportions into a variable that 
can be included in the `stat` data frame.
- Illustrate base R and `dplyr` approaches.

## Example 1: split

\small

- The base R function `split()` splits a data frame
on a grouping variable, which is a vector or 
list of vectors that can be coerced to factor(s),
and returns a list.

\scriptsize

```{r}
sp.stat <- split(stat,stat$year)
names(sp.stat)
head(sp.stat[["2008"]])
str(sp.stat[["2008"]])
```

## Example 1: Split, cont.

\scriptsize

```{r}
sp.stat <- split(stat,list(stat$year,stat$Subject))
names(sp.stat)
head(sp.stat[["2008.STAT"]])
```

## `group_by()` from `dplyr`

\small

- Call is similar to `split`, but we specify multiple
variables to group on by comma-separated
names.
- Output is a `tbl`. Supposed to be a user-friendly
data table. Implementation details not clear.

\scriptsize

```{r}
sp.stat.dplyr <- group_by(stat,year,Subject)
sp.stat.dplyr
```


## Example 1: Apply 

\small

- Create a new variable
`FTEproportion = FTEs/sum(FTEs)` for each 
sub-group data frame and save the new variable
in the respective data frames.
- Can use the base R function `lappy()`
    - stands for "list apply" -- apply a function to 
    each element of a list and return a list as output
- It turns out the following call to `lapply()` does what
we want. 

\scriptsize

```{r}
tem <- lapply(sp.stat,transform,FTEproportion=FTEs/sum(FTEs))
```

\small

- To see why, start with simpler uses of `lapply()`.

## Simpler example of `lapply()`

\small

- Define a function to apply to each list element and
apply it:
```{r}
fsum <- function(x) { # x is a list element
  sum(x$FTEs) # assumes list elements have an FTEs column
}
tem <- lapply(sp.stat,fsum)
tem[1:2]
```

## Simpler example, cont.

\small

- If our function takes more arguments than just
the list element, we add them after the function name.

\scriptsize

```{r}
fsum <- function(x,cname) {
  sum(x[,cname]) 
}
tem <- lapply(sp.stat,fsum,"FTEs")
tem[1:2]
```

## Our use of `lapply()`

\small

- Adding a column to each sub-group data frame 
requires a function that takes the data frame
as an argument and returns the augmented version.
    - This is what `transform()` does

\scriptsize

```{r}
head(transform(sp.stat[[1]],FTEproportion = FTEs/sum(FTEs)))
```


## Putting it all together

\scriptsize

```{r}
sp.stat <- lapply(sp.stat,transform,FTEproportion=FTEs/sum(FTEs))
head(sp.stat[[1]])
```

## Detour: The apply family of functions in R

\small

- The "original" apply is `apply()`, which can 
be used to apply a function to rows or columns 
of a matrix.

\scriptsize

```{r}
mat <- matrix(1:6,ncol=2,nrow=3)
mat
apply(mat,1,sum) # row-wise sums; rowSums() is faster
apply(mat,2,sum) # column-wise; colSums() is faster
```

## Detour, cont.

\small

- `sapply()` takes the output of `lapply()` and simplifies
to a vector or matrix.

\scriptsize

```{r}
fsum <- function(x) { sum(x$FTEs) }
sapply(sp.stat,fsum)[1:2]
````

## Detour, cont.

\small

- Other `apply`-like functions `vapply()`, `mapply()`,
`tapply()`, ...
- I don't use these.
    - See their respective help pages for information.
    


## The apply step with `dplyr`

\small

- Actions ("verbs") like `mutate()` are applied
to the data within groups when passed a 
grouped object.
    - That is, the data table is broken into groups and 
    `mutate()` is applied separately to each group.
    
\scriptsize

```{r}
sp.stat.dplyr <- mutate(sp.stat.dplyr,FTEpp = FTEs/sum(FTEs))
select(sp.stat.dplyr,Subject,FTEs,year,FTEpp)
```

## The combine step

\small

- The base R function `unsplit()` will combine
the elements of the list that was generated by `split()`
- Pass `unsplit()` the list of variables used
to define the splits.

\scriptsize

```{r}
head(unsplit(sp.stat,list(stat$year,stat$Subject)))
```

## The combine step with `dplyr`

\small

- Use `ungroup()`

\scriptsize

```{r}
ungroup(sp.stat.dplyr) %>% select(Subject, FTEs, FTEpp)
```

## Summary of split-apply-combine

\scriptsize

- Base R:

```{r}
sp.stat <- split(stat,list(stat$year,stat$Subject))
sp.stat <- lapply(sp.stat,transform,FTEproportion = FTEs/sum(FTEs))
stat <- unsplit(sp.stat,list(stat$year,stat$Subject))
```

- `dplyr`

```{r}
stat %>% group_by(year,Subject) %>% 
  mutate(FTEproportion = FTEs/sum(FTEs)) %>%
  ungroup() -> stat
```

## Split-apply-combine with `summarise()`

\small

- In the apply step, we may wish to calculate some
sort of summary, rather than a transformation
of a variable.
- For example, suppose we want to calculate 
total FTEs by year and subject, and return 
a data frame

\scriptsize

```{r}
stat %>% group_by(year,Subject) %>% 
  summarise(totalFTEs = sum(FTEs)) %>%
  ungroup() -> totals
head(totals,n=4)
```

## Split-apply-combine with `lapply()`

\small

- Compare to base R

\scriptsize

```{r}
tem <- split(stat,list(stat$year,stat$Subject))
tem <- lapply(tem,function(x) sum(x$FTEs))
tem[1:4]
```

- Then would have to write code to coerce 
output to a data frame.


